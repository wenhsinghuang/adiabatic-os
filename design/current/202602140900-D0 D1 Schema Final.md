# 202602140900 D0 D1 Schema — Final

One-way door。這兩張表定了，資料進去了，改就要 migrate。

D2 schema 設計就是 .db format

---

## D0: events

系統的記憶。Append-only。每筆 write 自動產生一條。

```sql
CREATE TABLE events (
  id          TEXT PRIMARY KEY,
  source      TEXT NOT NULL,
  type        TEXT NOT NULL,
  external_id TEXT,
  started_at  INTEGER NOT NULL,
  ended_at    INTEGER,
  payload     JSON NOT NULL,
  created_at  INTEGER NOT NULL DEFAULT (unixepoch('subsec')*1000)
);

CREATE INDEX idx_events_source ON events(source, started_at DESC);
CREATE INDEX idx_events_type ON events(type, started_at DESC);
CREATE UNIQUE INDEX idx_events_dedup ON events(source, external_id)
  WHERE external_id IS NOT NULL;
```

### Column 說明

| Column | 型別 | 為什麼存在 |
|--------|------|-----------|
| `id` | TEXT PK | ULID。天然按時間排序，分散式 friendly。 |
| `source` | TEXT NOT NULL | 誰產生的。用 convention 編碼身份：`app:focus-tracker`、`connector:oura`、`system:optimizer`, `user:edit`。主要 filter 軸，需要 index。取代了獨立的 `actor` column。 |
| `type` | TEXT NOT NULL | 什麼事。`sleep.recorded`、`d2.row.inserted`、`d1.doc.updated`。另一個主要 filter 軸，需要 index。命名跟隨 CloudEvents 標準。 |
| `external_id` | TEXT | 外部系統的 ID（Oura sleep ID、GitHub commit SHA）。用於 dedup — connector 重跑不會重複塞。nullable，內部 event 沒有外部 ID。需要 unique index（跟 source 組合）。 |
| `started_at` | INTEGER NOT NULL | 事件實際發生的時間（unix ms）。不是寫入時間。主要排序軸，幾乎每個 query 都用。 |
| `ended_at` | INTEGER | 結束時間。duration event（睡眠、focus session）需要。nullable — point event 沒有 duration。跟 started_at 成對，duration query 需要兩者。 |
| `payload` | JSON NOT NULL | 實際資料。Schema-free。每種 event 內容不同，不可能用固定 column 涵蓋。也是所有「不值得獨立成 column」的資訊的去處。 |
| `created_at` | INTEGER NOT NULL | 寫入系統的時間（unix ms）。跟 started_at 不同 — Oura 昨晚的睡眠今天早上才 sync 進來。系統運維用（sync lag、late arrival）。 |

---

## D1: docs

用戶思考的地方。同時是 data 和 interface。Hard delete OK — D0 有完整編輯軌跡。

```sql
CREATE TABLE docs (
  id          TEXT PRIMARY KEY,
  content     TEXT NOT NULL DEFAULT '',
  metadata    JSON,
  created_at  INTEGER NOT NULL,
  updated_at  INTEGER NOT NULL
);

CREATE INDEX idx_docs_updated ON docs(updated_at DESC);
```

### Column 說明

| Column | 型別 | 為什麼存在 |
|--------|------|-----------|
| `id` | TEXT PK | 可帶語意：`journal/20240214`、`weekly/2024-w07`，或純 ULID。 |
| `content` | TEXT NOT NULL | MDX 原文。docs table 存在的核心理由 — SQL queryable、可 chunk、可 embed、可直接 render。Yjs binary 做不到這些。 |
| `metadata` | JSON | 彈性補丁。title、path、tags、doc_type — 什麼都能塞，不用 migrate。跟 D0 的 payload 同一個 escape hatch pattern。 |
| `created_at` | INTEGER NOT NULL | 何時建立。 |
| `updated_at` | INTEGER NOT NULL | 最後修改。Sidebar 排序、Optimizer 偵測最近變更、sync 判斷。 |

---

## 設計原則

**Column 存在標準：被 index / 是主要 query 軸 / 有 constraint 需求。** 過不了這關就進 JSON（D0 `payload`、D1 `metadata`）。

**兩張表的共通 pattern：**
- TEXT PRIMARY KEY（分散式 friendly，不用 auto-increment）
- JSON 作為 escape hatch（不用 migrate 就能加欄位）
- INTEGER 存時間（unix ms，跨平台、可比較、可運算）

**兩張表的差異反映用途：**

| | D0 events | D1 docs |
|---|---|---|
| 角色 | 系統的記憶 | 用戶的思考 |
| 寫入模式 | append-only | mutable |
| 刪除策略 | 永不刪 | hard delete（D0 是安全網） |
| 核心資料 | `payload` JSON | `content` TEXT |
| 時間語意 | started_at/ended_at（事件時間）| created_at/updated_at（文件生命週期）|

---

## System API

App 跟 OS 互動的唯一介面。存在的最大理由：auto D0 logging。

```ts
system.query(sql, params)              // 讀（D0, D1, D2）
system.write(sql, params)              // D2 DML（auto D0 log）
system.writeDoc(id, content, meta?)    // D1 upsert（auto D0 log）
system.deleteDoc(id)                   // D1 hard delete（auto D0 log）
system.writeEvent(event)               // D0 顯式寫入（connector / 自訂 event）
system.promote(config)                 // DDL：建 D2 table（auto D0 log）
system.demote(table)                   // DDL：歸檔 D2 table（auto D0 log）
```

**為什麼不能再少：**
- `writeDoc` 不能合進 `write` — D1 有特殊語意（auto timestamps、future CRDT、working tree materialization），DX 也差太多
- `writeEvent` 獨立存在 — connector 直接寫 D0，不是在寫 D1/D2
- `promote`/`demote` 不能用 `write` — DDL vs DML 權限等級不同

**Source 自動帶上：** App 在 sandbox（Worker thread）裡，main process 知道是哪個 Worker → `source = "app:{app_id}"`。App 不能偽造 source。

---

## Auto D0 Log — 每個 API 寫什麼

| API call | D0 type | payload |
|----------|---------|---------|
| `write`（INSERT） | `d2.insert` | `{table, row}` |
| `write`（UPDATE） | `d2.update` | `{table, row}`（更新後） |
| `write`（DELETE） | `d2.delete` | `{table, row}`（刪前讀出） |
| `writeDoc` | `d1.write` | `{doc_id, bytes}`（行為信號，不存完整 content） |
| `deleteDoc` | `d1.delete` | `{doc_id, content, metadata}`（完整快照，安全網） |
| `promote` | `ddl.promote` | `{table, columns}` |
| `demote` | `ddl.demote` | `{table}` |
| `writeEvent` | —（本身就是 D0） | 不產生額外 event |
| `query` | —（讀不記） | — |

**writeDoc 不存完整 content，只存 metadata（doc_id, bytes）。** 理由：doc 頻繁編輯，每次存全文太浪費。行為信號（何時、多大）對 Optimizer 已夠用。要版本歷史，以後加 diff 或定期 snapshot — payload 格式是 two-way door。

**deleteDoc 存完整 content。** Hard delete 的安全網。D0 append-only，永遠在。

**D2 DELETE 存被刪的 row。** 刪前讀出來寫進 payload，否則資料真的消失。

---

## Lock（隱私）

用 `metadata.locked` 標記，不改 schema。

**D1 doc lock：**
```json
{ "id": "journal/private", "metadata": { "locked": true } }
```

Guard 行為：locked doc 寫入 docs table ✓，不寫 D0 ✗，不 sync 到雲端 ✗。

**D2 table lock：** manifest 標記 `"local_only": true`，整張表不 sync、不 log。

**D0 連帶 lock：** 用戶 lock 一個 doc 或 table 時，已存在的相關 D0 event 不需要刪（append-only 原則不破壞）。Sync 層過濾：sync D0 時排除 `payload.doc_id` 在 locked docs 裡的、`payload.table` 在 local_only tables 裡的 event。本機保留完整歷史，雲端看不到 locked 內容。

---

## 砍掉的東西

### D0 砍掉的

| 砍了什麼 | 為什麼砍 |
|----------|---------|
| `actor` column | 跟 source 重疊。source convention（`app:xxx`、`system:xxx`）已編碼身份。每個具體 case 都能從 source + type 推出 actor 是誰。 |
| `kind` 命名 | 改為 `type`。跟隨 CloudEvents 標準，更直覺。SQLite 和 TypeScript 都不衝突。 |

### D1 砍掉的

| 砍了什麼 | 為什麼砍 |
|----------|---------|
| `title` column | 可從 content 第一行推導，或放 metadata。不值得獨立 column。需要時 `ALTER TABLE ADD COLUMN` 加回來（two-way door）。 |
| `yjs_state` column | Yjs best practice 是獨立 table（`yjs_updates`），由 Yjs provider 自己管。不該跟 doc 混在一起。 |
| `deleted_at` column | Hard delete OK。D0 append-only 記錄了完整編輯軌跡（每次 writeDoc 都 auto-log）。D1 是 working surface，D0 才是 permanent memory。刪 doc = 清理桌面，不是銷毀記憶。要「垃圾桶」UX 是 app 層的事。 |
| `doc_versions` table | D0 event stream 已記錄每次 writeDoc。如果 payload 帶 content snapshot，版本序列已在 D0 裡。額外 version table = 重複儲存。 |
| `doc_type` column | 放 metadata JSON。不是每個 doc 都有 type，不值得獨立 column。 |

### 整個砍掉的概念

| 砍了什麼 | 為什麼砍 |
|----------|---------|
| `entities` table | SQLite 內建 introspection（`sqlite_master`、`PRAGMA table_info`）+ app manifest + D0 event log 已覆蓋所有 metadata 需求。 |
| Row namespace | D0 auto-log 已記錄每筆 write 的來源和時間。不需要在 D2 table 強制加 `created_by`、`updated_at` 等 column。 |
| Soft delete for D1 | 見上。D0 是 permanent memory，D1 是 working surface。 |
